# Тестовое задание

## Введение
Сервис предполагает 2 уровня вложености

1) Персона - человек с ФИО
2) Документы человека (это наличие определенных документов у человек. Например, справок)

## Содержание данной записки
1) Выполненая работа с обоснованием
2) Улучшения и перспективы

## 1. На данный момент
### 1.1 Ручки
Сейчас реализован CRUD по требованиям. На "/person" привязано четыре метода.

[GET] - для получения пользователя по ID

Если в json-структуре не будет поля ID, то вернется 400ый статус

Пример запроса который нужно отправить:

`{"id":1}`

[POST] - для создания пользователя

Пример запроса, котрый нужно отправить:

`{ "firstName":"Ivan", "secondName":"Ivanov","middleName":"Ivanovich", "documents":[{"id":1, "name":"Справка"},{"id":2, "name":"Документ"}]}`

[PUT] - для обновления пользователя

Если не указан id, то вернется 400ый статус

Пример запроса, котрый нужно отправить:

`{"id":1, "firstName":"Ivan", "secondName":"Ivanov","middleName":"Ivanovich"}`

[DELETE] - для удаления пользователя

Если не указан id, то вернется 400ый статус

Пример запроса, котрый нужно отправить:

`{"id":1}`

### 1.2 Внедрение зависимостей
На данный момент в "app.go" я все прописываю руками. В идеале, при масштабируемости (да и в целом желательно), использовать wire. На данный момент wire не добавлен, но система разработана так, что добавить его не проблема

### 1.3 Контроллеры, хендрелы, сервисы и репозитории
Сейчас структура папок такова, что например в контроллерах у нас нет деления на папки. То есть в директории controllers при масштабируемости и добавления контроллеров по другим сущностям в идеале надо создать папки "person" и "documents"

По аналогии в других папках - repo, services и handlers.

### 1.4 Обоснование некоторых выборов
#### 1.4.1 Идентификатор

Передо мной был выбор использовать автоинкрементируемый идентификатор через возможности Reindexer "id=serial()" или uuid.

На данный момент я выбрал автоинкрементируемый идентификатор, т.к. не знаю, как данный микросервис использовался в дальнейшем, а для проверки "ручек" так было проще.

Возможно, правильно было бы выбрать "uuid" т.к. для микросервисов обычно выбирают его. Потому, что во время использования автоинкрементируемых идентификаторов - "айдишники" на фронте могут перемешиваться, однако они будут перемешиваться только если фронт не правильно написан.

Если бы я это делал сразу в прод и не договаривался с фронтом, то я бы использовал uuid.

#### 1.4.2 Хранение времени
Сейчас время о только что созданой записи или обновлении создается через "time.Now().String()". Хранить тип "time.TIME" на бекенде я не могу, поэтому решил хранить в строковом значении и в будущем я смогу распарсить её в нужный формат (если это нужно будет) 

#### 1.4.3 Подключение к Reindexer

Подключение происходит через RPC. В Reindexer он подключается достаточно просто и обеспечивает высокую производительность т.к. это бинарный протокол (как в Reindexer это работает под капотом ещё не успел изучить), а HTTP/Rest я решил не использовать потому, что он понизит производительноть в данном случае.

## 2. Улучшения и перспективы
### 2.1 Проблема с UPDATE(PUT)
Сейчас, чтобы корректно обновить "Person" нужно отправить всю карточку(со всеми полями и даже createAt). На данный момент это ключевая проблема(для меня), потому что я не хочу передавать все данные на фронт и тем более, чтобы все данными управлял фронт. Так же можно решить методом - достать из бд старого пользователя и перезаписать новые поля, но это лишний запрос в бд, а это сильно повлияет на производительность. Для тестовой версии это может и пойдет, но в ближайшее время хочу это исправить.

### 2.2 Реализация кэша
Сейчас кеша нет. Реализацию планирую сделать через in memory store, тк пока что не предполагается, что другие приложения будут использовать кэш, поэтому подключение Redis будет излишним. Чтобы не было проблем с получением данных из memstore - буду использовать Mutex.

### 2.3 Документы у персон
Сейчас есть только создание документов в GET запросе при создании пользователя (при обновлении они пропададут, что является критической ошибкой). В следующей итерации доработаю работу с документами.

### 2.4 Пагинация
Т.к. задача достаточно абстрактная, то я собираюсь использовать курсорную пагинацию. В запросе будет передаваться лимит записей, айдипоследней записи и поиск по тексту. (метод сработает с автоинкрементным айди, если сорт будет по айди. Возможно в вводом поля сорт надо будет переделать метод с пагинацией)

### 2.5 Сортировка
Поле sort не добавлено и проблем это в следующей итерации не составит. Посредством пакета от разработчика

// Сортировка по полю


query := db.Query("actors").Sort("id", false)

### 2.6 Потоковая обработка документов
Это является самой интересной для меня задачей. Сейчас думаю, что буду реализовывать через каналы, но изучаю разные методы для реализации этой задачи

### 2.7 Докер-образ
Под конец всех исправлений хочется, чтобы проект был в Dockerfile, чтобы его можно было легко развернуть с тем зависимостями, на которых он разрабатывался